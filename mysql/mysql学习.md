# InnoDB数据页

> 我们学习的目标是InnoDB存储引擎。在InnoDB中数据会存在磁盘上，当我们处理数据时需要将数据从磁盘中读取加载到内存中。InnoDB存储引擎不需要一条一条的从磁盘中读取数据，而是以数据页的方式从磁盘中读取数据。
>
> 数据页是InnoDB管理存储空间的基本单位，默认大小为16KB。

```mysql
#可以查看数据页存储大小
SHOW GLOBAL STATUS like 'Innodb_page_size'; 
```

# InnoDB行格式

> 上一节中我们说道，InnoDB是使用数据页的方式存储一条或者多条数据的，那每条数据在数据页中以什么方式进行存储的呢？
>
> 一条记录在数据页中是以行格式进行存储的，行格式有Compact、Redundant、Dynamic、Compressed集中类型，我们主要学习Compact行格式。

```mysql
#创建表时指定行格式
CREATE TABLE 表名  (列信息)  ROW_FORMAT=行格式名称；

#修改表的行格式
ALTER TABLE 表名 ROW_FORMAT=行格式名称；
```

**Compact行格式结构如下**

![image-20220718144407875](https://raw.githubusercontent.com/GJKGJKGJK/MyImageBed/master/typora_imgs/20220823143832.png)

>行格式中除了记录各字段数据外，还记录了一些额外的信息，额外信息如下：
>
>* 可变字段长度列表
>
> MySql支持一些变长的数据类型，如varchar、varbinary、text、blob，使用这些数据类型的字段为可变字段。可变字段的真实数据占用的字节长度都存放在可变字段长度列表中。
>
>* NULL值列表
>
> 将为null的列统一管理起来，存一个标记位在NULL值列表中。二进制位的值为1时，代表该列的值为null，二进制位的值为0时，代表该列的值不为null。如果表中的字段都不允许为null，则NULL值列表也不存在。
>
>* 记录头部信息
>
> 用于描述记录的信息，由固定的5个字节组成，5个字节也就是40个二进制位，不同的位代表不同的意思。
>
>| 名称         | 大小(bit) | 描述                                                         |
>| :----------- | :-------- | :----------------------------------------------------------- |
>| 预留位1      | 1         | 没有使用                                                     |
>| 预留位2      | 1         | 没有使用                                                     |
>| delete_mask  | 1         | 标记该记录是否被删除                                         |
>| min_rec_mask | 1         | B+树里每层非叶子节点里面的最小记录都会添加这个标记           |
>| n_owned      | 4         | 表示当前记录拥有的记录数                                     |
>| heap_no      | 13        | 表示当前记录在记录堆里的位置信息                             |
>| record_type  | 3         | 表示当前记录的类型，0表示普通，1表示B+树非叶子节点，2表示最小记录，3表示最大记录 |
>| next_record  | 16        | 表示下一条记录的相对位置                                     |
>
>* 记录真实数据
>
> 用于记录我们定义的列的数据和三个隐藏列
>
> * row_id                 行ID,记录的唯一标识
> * transaction_id     事务ID
> * roll_pointer         回滚指针

# 1、一条SQL查询语句是如何执行的？

> 下面是MySql的基本架构示意图，从中我们可以清楚的看到查询SQL语句在MySql的各个功能模块中执行的过程

![image.png](https://raw.githubusercontent.com/GJKGJKGJK/MyImageBed/master/typora_imgs/20220823143848.png)

> MySql主要分为Server层和存储引擎层，后面会详细讲解每个组件的作用。
>
> Server层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖了MySql的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学、加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。
>
> 存储引擎层负责数据的存储和提取，其架构模式是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎。目前最常用的存储引擎是InnoDB，从**MySql5.5.5版本**开始成为默认存储引擎。

## 连接器

> 第一步，你会先连接到这个数据库上，这时候接待你的就是连接器。连接器负责跟客户端建立连接、获取权限、维持和管理连接。连接命令一般是这么写的：
>
> ```mysql
> mysql -h$ip -P$port -u$user -p
> ```
>
> 连接命令中的 mysql 是客户端工具，用来跟服务端建立连接。在完成经典的 TCP 握手后，连接器就要开始认证你的身份。如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限
>
> 连接完成后，如果你没有后续的动作，这个连接就处于空闲状态，你可以在 show processlist 命令中看到它。
>
> ![image-20220802102523265](https://raw.githubusercontent.com/GJKGJKGJK/MyImageBed/master/typora_imgs/20220823145411.png)
>
> 其中的 Command 列显示为“Sleep”的这一行，就表示现在系统里面有一个空闲连接。客户端如果太长时间没动静，连接器就会自动将链接断开。这个时间由参数wait_timeout控制的，默认值为8小时。

> 数据库中的连接分为短连接和长连接。
>
> * 短连接指每次执行完很少的几次查询就断开链接，下次查询再重新建立链接。 
> * 长连接则指连接成功后如果客户端持续有请求，则一直使用同一个连接。
>
> 建立连接的过程比较复杂，所以建议尽量减少建立连接的动作，也就是尽量使用长连接。
>
> 但是当全部使用长连接后，我们可能会遇到MySQL占用内存较高，这是因为MySQL在执行过程中临时使用的内存是管理在连接对象中的，这些临时使用的内存资源只有在连接断开时，才能得以释放。
>
> 如果长连接累积数量较大，可能导致内存一直被占用，得不到释放，最终出现OOM问题。从现象看就是MySQL异常重启了。
>
> 怎么解决这个问题呢？下面有两种方案。
>
> * 定期断开长连接。使用一段时间或者程序里面判断执行过一个占用内存较大的查询后，断开连接，之后要查询再重新连接。
> * 如果用的是MySQL5.7或者更高版本，可以在每次执行一个较大的操作后，通过执行**mysql_reset_connection**来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建时的状态。

## 查询缓存

> MySQL 拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以 key-value 对的形式，被直接缓存在内存中。key 是查询的语句，value 是查询的结果。如果你的查询能够直接在这个缓存中找到 key，那么这个 value 就会被直接返回给客户端。
>
> 如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。你可以看到，如果查询命中缓存，MySQL 不需要执行后面的复杂操作，就可以直接返回结果，这个效率会很高。
>
> **但是大多数情况下我会建议你不要使用查询缓存，为什么呢？因为查询缓存往往弊大于利。**
>
> 只要表更新，这个表的查询缓存全部失效，很可能费劲存起来的结果，还没使用就被清空。因此对于频繁更新的表不适合使用查询缓存，而对于不经常更新的表适合使用查询缓存，比如一张系统配置表。
>
> MySQL提供了一种**按需使用**的方式。可以将参数**query_cache_type**设置成**DEMAND**。这样对于默认的SQL都不使用查询缓存，而对于需要使用查询缓存的SQL，可以使用SQL_CACHE显示指定，像下面这个语句一样：
>
> ```mysql
> mysql> select SQL_CACHE * from T where ID=10；
> ```
>
> 需要注意的是，MySQL8.0版本直接将查询缓存的整个功能删除了，彻底放弃了查询缓存功能。

## 分析器

> MySQL 需要知道你要做什么，就需要对SQL语句进行解析。
>
> 分析器先会做“词法分析”。MySQL 需要识别出里面的SQL语句中各个字符串分别是什么，代表什么。
>
> 然后再做“语法分析”。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。

## 优化器

> 查询sql经历过分析器处理后，MySQL就知道我们要做什么。执行查询sql前，要经过优化器的处理。
>
> 优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。比如在执行下面的语句时，优化器可选择的处理方案：
>
> ```mysql
> mysql> select * from t1 join t2 using(ID)  where t1.c=10 and t2.d=20;
> ```
>
> * 既可以先从表 t1 里面取出 c=10 的记录的 ID 值，再根据 ID 值关联到表 t2，再判断 t2 里面 d 的值是否等于 20。
> * 也可以先从表 t2 里面取出 d=20 的记录的 ID 值，再根据 ID 值关联到 t1，再判断 t1 里面 c 的值是否等于 10。
>
> 两种方式执行结果是一样的，但是执行效率可能不同。而优化器的作用就是决定使用哪种方案。

## 执行器

> MySQL 通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。 
>
> 开始执行时，**先判断当前用户是否有表的权限**。如果没有，则返回没有权限的错误，如下所示(如果在查询缓存中命中，则在查询缓存返回结果时做权限验证)：
>
> ```mysql
> mysql> select * from T where ID=10;
>  
> ERROR 1142 (42000): SELECT command denied to user 'b'@'localhost' for table 'T'
> ```
>
> 如果有权限，则打开表继续执行，**执行器调用表的存储引擎提供的接口**。以上述例子为参考，ID字段有没有索引，执行器调用存储引擎的接口也存在差异。
>
> 当ID字段不存在索引时：
>
> * 先调用InnoDB引擎**获取第一行**接口，判断ID是否为10，如果不是跳过，如果是则将这行数据存入结果集中。
> * 再调用InnoDB引擎**获取下一行**接口，重复相同的判断逻辑，直到表的最后一行记录。
> * 执行器将上诉过程中所有满足条件的行，组成结果集返回客户端
>
> 当ID字段存在索引时：
>
> * 先调用InnoDB引擎**获取满足条件的第一行**接口，存入结果集
> * 再调用InnoDB引擎**获取满足条件的下一行**接口，重复相同的判断逻辑，直到表的最后一行记录。
> * 执行器将上诉过程中所有满足条件的行，组成结果集返回客户端
>
> 存不存在索引，执行器的执行逻辑差不多，只是调用接口不同。这些接口都是存储引擎已经定义好并提供出来的。

# 2、一条SQL更新语句是如何执行的

> 前面我们学习了查询SQL在MySQL中的一个执行过程，其实更新语句同样会走一遍这个过程。
>
> ![image.png](https://raw.githubusercontent.com/GJKGJKGJK/MyImageBed/master/typora_imgs/20220823145429.png)
>
> 查询SQL和更新SQL执行链路的不同点在于：
>
> * 1、**查询缓存的使用，查询SQL优先从查询缓存中查找数据，而更新SQL会让更新表有关的查询缓存全部清空**，这也是一般不建议使用查询缓存的原因。
> * 2、更新SQL执行链路涉及到两个重要日志模块：**redo log（重做日志）** 和 **binlog（归档日志）**，下面我们重点学习这两个日志模块。

## redo log

> 首先讲个故事：《孔乙己》这篇文章中，酒店掌柜有一个粉板，专门用来记录客人赊账记录。如果赊账的人不多，那么他可以把顾客名和账目写在粉板上，等打烊后在整理到账本上。但是如果赊账的人多了，粉板总有记不下的时候，掌柜只好放下手中的活，先把粉板上一部分赊账记录更新到账本上，然后将这些记录从粉板上擦除，为记新账腾出空间。
>
> 而粉板和账本配合的过程，其实就是MySQL里面经常说的WAL（Write-Ahead Logging）技术。它的关键点就是**先写日志，再写磁盘**。具体来说，当一条记录更新时，InnoDB引擎会先把记录写到redo log里面，并更新内存，同时InnoDB引擎会在系统比较空闲的时候，将redo log中的操作记录更新到磁盘中。
>
> InnoDB的redo log是**固定大小**的，当"粉板"满了，会对"粉板"进行擦除，腾出可用空间。有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录也不会丢失，这个能力称为**crash-safe**。

## undo log

> 用于MVCC中，将数据库逻辑地恢复到原来的样子。undo日志用于事务的回滚操作进而保障了事务的原子性。
>
> DML操作修改聚簇索引前，记录undo日志；

## binlog

> MySQL整体可以分为Server层和引擎层。上面我们学习的redo log是InnoDB引擎特有的日志，而Server层也有自己的日志，称为binlog。
>
> 为什么会有两个日志模块？
>
> 因为最开始MySQL里没有InnoDB引擎，自带的引擎是MyISAM，但是MyISAM只有binlog日志，不具有crash-safe能力。而InnoDB引擎是另一家公司以插件形式引入MySQL的，既然binlog不具有crash-safe能力，他们就搞了另外一套日志模块——redo log来实现crash-safe功能。
>
> **redo log 和 binlog的区别**：
>
> * 1、redo log是InnoDB引擎特有的；binlog是MySQL的server层实现的，所有引擎均可使用。
> * 2、redo log是物理日志，记录的是“在某个数据页上做了什么改变”；binlog是逻辑日志，记录的是更新语句原始逻辑，比如“给ID=2这一行的c字段加1”。
> * 3、redo log大小固定的，空间用完会进行擦除、循环写入；binlog是可以追加写入的，binlog文件写到一定大小后会创建新的日志文件写入，而不是覆盖之前的日志文件。

## update执行流程

> 现在有了对上面两个日志的理解，我们再回过头看看update语句在执行器和InnoDB引擎层的执行流程，以下面的sql为例，浅色框表示在InnoDB内部执行的，深色框表示在执行器中执行的
>
> ``` mysql
> mysql> update T set c=c+1 where ID=2;
> ```
>
> ![image-20220823133626804](https://raw.githubusercontent.com/GJKGJKGJK/MyImageBed/master/typora_imgs/20220823145432.png)
>
> * 1、执行器先通过引擎接口获取 ID=2 这一行。ID是主键，引擎直接用树搜索找到这一行记录。如果ID=2这一行所在数据页本来就在内存中，直接返回给执行器；否则，需要先从磁盘读入内存，再返回。
> * 2、执行器拿到记录后，进行修改，得到新的一行数据，再调用引擎接口写入这行新数据。
> * 3、引擎将这行数据更新到内存中，同时将这个更新操作记录到redo log中。此时redo log处于prepare状态。然后告知执行器执行完成了，随时可以提交事务。
> * 4、执行器收到执行完成结果后，生成更新操作的binlog，并把binlog写入磁盘。
> * 5、执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交（commit）状态，更新完成。
>
> redo log的写入拆分成了两个步骤：prepare和commit，这就是**两段式提交**。
>
> 为什么要将redo log拆分成两段式提交呢？
>
> 不管先写redo log后写binlog ，还是先写binlog后写redo log，都不能保证数据库数据和用日志恢复出来的库的数据一致。同时这个“不一致”也会导致线上出现主从数据库的不一致问题。而**两阶段提交就是让这两个状态保持逻辑上的一致**。

# 3、事务隔离

> 简单来说，**事务就是要保证一组数据库操作，要么全部成功，要么全部失败**。在 MySQL 中，事务支持是在引擎层实现的。MySQL 是一个支持多引擎的系统，但并不是所有的引擎都支持事务。比如 MySQL 原生的 MyISAM 引擎就不支持事务，这也是 MyISAM 被 InnoDB 取代的重要原因之一。
>
> 提到事务，我们肯定会想到ACID，即**原子性**、**一致性**、**隔离性**、**持久性**。今天学习学习MySQL的隔离性怎么实现的。

## 事务隔离级别

> 当数据库有多个事务同时执行时，就可能出现**脏读**（dirty read）、**不可重复读**（non-repeatable read）、**幻读**（phantom read）的问题，为了解决这些问题，就有了“隔离级别”的概念。SQL 标准的事务隔离级别如下：
>
> * **读未提交**是指，一个事务还没提交时，它做的变更就能被别的事务看到。
> * **读提交**是指，一个事务提交之后，它做的变更才会被其他事务看到。
> * **可重复读**是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。
> * **串行化**，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。
>
> *MySQL的默认事务隔离级别是可重复读，Oracle默认事务隔离级别是读已提交* 

## MVCC

> 不同的事务隔离级别可以解决脏读、幻读、不可重复读问题，那么这些事务隔离级别是如何实现的呢？InnoDB存储引擎是通过**MVCC(多版本控制器)**实现的。
>
> 对于使用InnoDB存储引擎的表来说，它的每条行记录中都包含三个必要的隐藏列：
>
> * row_id
> * trx_id : 每次对某条记录进行改动时，都会把对应的事务id赋值给trx_id隐藏列。
> * roll_pointer : 每次对某条记录进行改动时，这个隐藏列会存一个指针，可以通过这个指针找到该记
>   录修改前的信息。
>
> 当我们对同一条数据多次修改时，**每个操作都将在trx_id列记录当前事务ID，并且通过roll_pointer列指向前一次操作,最终记录到undo log日志(回滚日志)中**，这些日志记录就会形成一条**版本链**。
>
> ![image-20220822181152879](https://raw.githubusercontent.com/GJKGJKGJK/MyImageBed/master/typora_imgs/20220823145435.png)
>
> 通过**版本链**，我们可以实现**读未提交**事务隔离级别，每次读取数据时，读取的都是**版本链最新一条数据**即可，而对于使用**序列化**事务隔离级别，使用**加锁**的方式访问记录。
>
> 但是对于**读已提交**和**可重复读**，仅仅通过版本链是无法实现的，核心问题是需要判断版本链中哪个版本是当前事务可见的。
>
> MySQL是通过**ReadView**来控制读已提交和可重复读需要读取的版本。
>
> 当事务隔离级别是**读已提交**时，**事务中每次读取数据前都重新生成一个ReadView**，在版本链中从新往旧读取数据，读取到第一个事务ID不在ReadView中的记录为止，此时的数据就是最新提交的数据。
>
> 当事务隔离级别是可重复读时，**事务中只有在第一次读取数据前生成一个ReadView**，在版本链中读取数据时，只读取ReadView中事务ID的数据，此时的读取的数据可以实现可重复读。

## 事务启动方式

> 1、显式启动事务语句：
>
> * begin
> * start transaction
>
> 提交事务语句：commit；回滚事务语句：rollback.
>
> Rollback语句是我们用来手动回滚事务的，但是当事务执行过程中遇到错误时，事务自身会进行自动回滚，不需要再执行rollback。
>
> 2、自动提交
>
> ```sql
> show  VARIABLES   like 'autocommit';
> ```
>
> 通过上面命令我们可以查看MySQL是否开启自动提交。如果**开启自动提交，我们每执行一个sql语句都是一个独立的事务**，这种特性为**事务的自动提交**。
>
> 如果我们想关闭自动提交，可以使用下面的方法：
>
> * 使用begin/start transaction，显式的开启事务，这样在本次事务提交或者回滚前都会暂时关闭自动提交功能
> * 通过 **SET autocommit = OFF;**命令关闭自动提交功能。
>

# 4、索引

> 如果有一本几百页的书，想快速找到某一章节，我们可以通过目录来快速查找。如果有几百万条数据，想快速找到某一条数据，我们也可以通过“目录”快速查找，而索引就是这个目录。**索引的出现就是为了提高查询效率**。

## 索引的常见数据结构

> * 哈希表
>
> 字段值所对应的数组下标是hash算法计算出来的，可能存在hash冲突。可以快速的精确查询，但是不支持范围查询，如果做成索引的话，需要全表扫描，速度也很慢。所以**哈希表只适用于等值查询的场景**
>
> * 有序数组
>
> 有序数组在等值查询和范围查询场景中的性能就都非常优秀，但是更新数据时，向数组中间插入一条数据，需要移动数组，成本太高。所以**有序数组索引只适用于静态存储引擎**。
>
> * 二叉树
>
> 二叉树是有序的，支持范围查询，二叉树得保持为平衡二叉树，查询和更新时间才能是最短的。但是当数据一多，树就会越高，查询成本就会增加。
>
> * B+树
>
> B+树只有叶子节点存储数据，同时会有一个指针指向下一个节点的叶子节点。叶子节点包含了这棵树的所有数据，所有的叶子结点使用链表相连，便于区间查找和遍历，所有非叶节点起到索引作用。

## InnoDB的索引模型

>在 InnoDB 中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。InnoDB 使用了 B+ 树索引模型，所以数据都是存储在 B+ 树中的。
>
>以下面的建表语句为例：同时表中有5条数据(100,1)、(200,2)、(300,3)、(500,5) 和 (600,6)。
>
>```mysql
>mysql> create table T(
>id int primary key, 
>k int not null, 
>name varchar(16),
>index (k))engine=InnoDB;
>```
>
>首先InnoDB会将数据存入B+树中。B+树的叶子节点存放完整的数据,所有的目录都存储在非叶子节点，形成**聚簇索引**。这种聚簇索引并不需要我们在MySQL语句中显式的使用INDEX语句去创建。InnoDB存储引擎会自动的为我们创建聚簇索引。在InnoDB存储引擎中，**聚簇索引就是数据的存储方式**（所有的用户记录都存储在了叶子节点），也就是所谓的索引即数据，数据即索引。聚簇索引如下图所示：
>
>![image-20220823182321244](https://raw.githubusercontent.com/GJKGJKGJK/MyImageBed/master/typora_imgs/20220823182328.png)
>
>其次，我们在建表时对k列创建了索引，此时创建的索引为**二级索引**。二级索引和聚簇索引的区别如下：
>
>* 按指定的索引列的值来进行排序
>* 叶子节点存储的不是完整的用户记录，而只是索引列+主键。
>* 目录项记录中不是主键+页号，变成了索引列+页号。
>* 在对二级索引进行查找数据时，需要根据主键值去聚簇索引中再查找一遍完整的用户记录，这个过程叫做
>  **回表**
>
>k列索引B+树展示如下：
>
>![image-20220823182815916](https://raw.githubusercontent.com/GJKGJKGJK/MyImageBed/master/typora_imgs/20220823182820.png)