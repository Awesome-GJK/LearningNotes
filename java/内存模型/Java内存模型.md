# 1.基本概念

> **进程**：程序在某些数据上的一次运行（动态概念）
>
> **线程**：一个进程可能包含一个或多个线程（占有资源的独立单元）

# 2.JVM和线程

> JVM什么时候启动？
>
> 某个类被调用时，JVM开始启动。启动时会执行JVM线程，JVM线程是一个系统线程。当JVM线程启动完毕后，会启动其他线程（main），所以线程是在JVM中的。

# 3.JVM内存区域

> **方法区**：线程共享区域，主要存放类信息、常量、static等信息
>
> **堆**：线程共享区域，主要存放对象实例，同时也是执行GC回收的重要区域。当堆内存放不下对象实例时，会抛出OOM异常
>
> **栈**：线程私有区域，Java线程执行方法的内存模型。线程中每个方法执行时，生成一个栈桢。栈桢中主要存放局部变量信息、引用数据类型存放地址，操作数栈，方法出口等信息。
>
> **程序计数器**：用来存储执行下一条指令的地址，指向方法区中方法的字节码。
>
> **本地方法栈**：和栈作用相同，区别是本地方法栈为JVM执行native方法服务，栈为JVM执行java方法服务。

# 4.Java内存模型

> 在JVM中，存放在方法区和Java堆中的数据是线程共享的，那么栈中信息怎么共享呢？换句话说，线程和线程之间如何实现数据共享呢？
>
> java内存模型(Java memory model)，也称为JMM。JMM是一个规范，指导数据在内存中进行交互操作。
>
> JMM工作模型如下：
>
> ![image.png](E:\learn&notes\notes\images\Java内存模型\wb8NQWXHUG2V31P.png)
>
> * 主内存：存放共享的信息
> * 工作内存：存放各线程的私有信息。
>   * 如果是基本数据类型，则直接分配到工作内存中。
>   * 如果是引用数据类型，则将引用的地址存放到工作内存中，引用的对象存放在堆中
>
>  工作方式：
>
> * 线程如果修改私有数据，直接在自己的工作内存中修改。
> * 线程如果修改共享数据，先从主内存中将数据复制到自己的工作内存，然后在工作内存中修改，最后将数据刷新到主内存的数据。
>
> 所以**栈中的数据是通过JMM内存模型指导数据进行交互的**。

# 5.硬件内存架构

> 现在我们知道了JMM内存模型，但是在硬件上是什么实现数据共享的呢？
>
> 首先各个CPU都有自己的寄存器，CPU操作数据时，先从寄存器中读取，如果寄存器中没有，则从L1、L2、L3缓存中获取。如果仍然没有数据，则从内存中读取。硬件内存数据交互结构图如下：
>
> ![image.png](E:\learn&notes\notes\images\Java内存模型\bNntvuR8UKj3rcy.png)
>
> 从这个架构图，我们可以发现当多个CPU同时处理一个数据时，存在**CPU缓存的一致性问题**。
>
> 解决方案如下：
>
> * 总线加锁
>
>   让指定CPU使用数据，但是会降低CPU的吞吐量
>
> * 缓存上的一致性协议 (MESI)
>
>   当CPU在CACHE中操作数据时，如果该数据是共享变量，数据在CACHE读到寄存器中，进行修改，并更新内存中的数据。同时将信号线（Cache Line）置位无效，让其他CPU从内存中读取数据。

# 6.Java内存模型与硬件内存架构的关系

![image.png](E:\learn&notes\notes\images\Java内存模型\RFbWvBmsKwNqGn5.png)

> 我们发现JMM内存模型和硬件内存架构基本上一致，那么他们之间又有什么联系呢？
>
> 在JMM内存模型中，工作内存中的数据可能存放在硬件架构图的寄存器中、Cache L1/L2/L3、内存中，同时主内存中的数据也可能存放在硬件架构图的寄存器中、Cache L1/L2/L3、内存中

# 7.Java线程与硬件处理器

> 在程序中执行某个操作，这个操作从软件到硬件经历了什么样的过程呢？
>
> 首先我们执行操作当作一个任务提交，由线程池中的线程执行任务，而操作系统OS会创建内核线程处理线程，交由CPU执行。
>
> ![image.png](E:\learn&notes\notes\images\Java内存模型\hTFeMH2QsWiCKEU.png)
>
> 整个过程就是**进程 -》线程 -》OS -》CPU**

# 8.Java内存模型与并发编程特性

> 首先我们先了解一下什么是并发编程特性
>
> * 原子性 ：多个操作不可分割
> * 可见性 ：线程只能操作自己工作空间中的数据
> * 有序性 ： 程序中代码的顺序不一定就是CPU执行字节码指令的顺序。存在编译重排序和指令重排序，重排序目的是提交代码执行效率。